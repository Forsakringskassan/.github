name: Build app into Docker image

on:
  workflow_call:
    inputs:
      registry:
        required: false
        type: string
        default: ghcr.io
      release:
        required: false
        type: boolean
        default: true
    secrets:
      PACKAGES_RW_ACTOR:
        required: true
      PACKAGES_RW_TOKEN:
        required: true

jobs:
  build-and-push:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: '22'
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Get and sanitize package name
        id: pkg
        run: |
          RAW_NAME=$(node -p "require('./package.json').name")
          CLEAN_NAME=$(echo "$RAW_NAME" | tr -d '@' | tr '/' '-' | tr '/' '--')
          echo "name=$CLEAN_NAME" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Package name: $RAW_NAME -> $CLEAN_NAME"

      - name: Determine next version (only if release)
        id: version
        if: ${{ inputs.release }}
        run: |
          nextVersion=$(npx git-changelog-command-line --print-next-version)
          echo "nextVersion=$nextVersion" >> $GITHUB_OUTPUT
          echo "ðŸ“„ Next version: $nextVersion"

      - name: Update package.json version
        if: ${{ inputs.release }}
        run: |
          VERSION="${{ steps.version.outputs.nextVersion }}"
          echo "ðŸ“„ Updating package.json to version $VERSION"
          npm version "$VERSION" --no-git-tag-version

      - name: Commit version bump
        if: ${{ inputs.release }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git add package.json
          git commit -m "chore: bump version to ${{ steps.version.outputs.nextVersion }}"
          git push origin HEAD

      - name: Build project
        run: npm run build
        env:
          APP_BASE_PATH: false

      - name: Prepare Docker context
        run: |
          mkdir docker
          cp -r dist docker/
          # Create Dockerfile that prints image name, version, and commit hash
          cat > docker/Dockerfile <<'EOF'
          FROM httpd:latest
          USER 0

          # Clean web root
          RUN rm -rf /usr/local/apache2/htdocs/*

          # Copy built app
          COPY dist/ /usr/local/apache2/htdocs/

          # Pass version info and image name as build args
          ARG NEXT_VERSION
          ARG GIT_COMMIT
          ARG IMAGE_NAME
          ARG BUILD_DATE
          ENV NEXT_VERSION=$NEXT_VERSION
          ENV GIT_COMMIT=$GIT_COMMIT
          ENV IMAGE_NAME=$IMAGE_NAME
          ENV BUILD_DATE=$BUILD_DATE

          # Set default port
          ENV HTTPD_PORT=8080

          # Create writable directories and set permissions for OpenShift/CRC
          RUN mkdir -p /tmp/apache2/logs /tmp/apache2/run && \
              chown -R www-data:www-data /usr/local/apache2/htdocs /tmp/apache2 && \
              chmod -R 755 /usr/local/apache2/htdocs && \
              chmod -R 777 /tmp/apache2

          # Create startup script that configures httpd with dynamic port and proper permissions
          RUN echo '#!/bin/bash' > /usr/local/bin/start-httpd.sh && \
              echo 'PORT=${HTTPD_PORT:-8080}' >> /usr/local/bin/start-httpd.sh && \
              echo 'cp /usr/local/apache2/conf/httpd.conf /tmp/httpd.conf' >> /usr/local/bin/start-httpd.sh && \
              echo 'sed -i "s/Listen 80/Listen $PORT/" /tmp/httpd.conf' >> /usr/local/bin/start-httpd.sh && \
              echo 'sed -i "s|ErrorLog logs/error_log|ErrorLog /tmp/apache2/logs/error_log|" /tmp/httpd.conf' >> /usr/local/bin/start-httpd.sh && \
              echo 'sed -i "s|CustomLog logs/access_log|CustomLog /tmp/apache2/logs/access_log|" /tmp/httpd.conf' >> /usr/local/bin/start-httpd.sh && \
              echo 'sed -i "s|#PidFile logs/httpd.pid|PidFile /tmp/apache2/run/httpd.pid|" /tmp/httpd.conf' >> /usr/local/bin/start-httpd.sh && \
              echo 'echo "PidFile /tmp/apache2/run/httpd.pid" >> /tmp/httpd.conf' >> /usr/local/bin/start-httpd.sh && \
              echo 'echo "ServerName localhost" >> /tmp/httpd.conf' >> /usr/local/bin/start-httpd.sh && \
              echo 'echo "Starting container: $IMAGE_NAME"' >> /usr/local/bin/start-httpd.sh && \
              echo 'echo "Version: $NEXT_VERSION"' >> /usr/local/bin/start-httpd.sh && \
              echo 'echo "Commit: $GIT_COMMIT"' >> /usr/local/bin/start-httpd.sh && \
              echo 'echo "Build date: $BUILD_DATE"' >> /usr/local/bin/start-httpd.sh && \
              echo 'echo "Listening on port: $PORT"' >> /usr/local/bin/start-httpd.sh && \
              echo 'echo ""' >> /usr/local/bin/start-httpd.sh && \
              echo 'echo ""' >> /usr/local/bin/start-httpd.sh && \
              echo 'httpd -D FOREGROUND -f /tmp/httpd.conf' >> /usr/local/bin/start-httpd.sh && \
              chmod +x /usr/local/bin/start-httpd.sh

          # Switch to www-data user for security
          USER www-data

          # Expose the configurable port
          EXPOSE $HTTPD_PORT

          # Use the startup script
          CMD ["/usr/local/bin/start-httpd.sh"]
          EOF

      - name: Build Docker image
        run: |
          IMAGE_BASE="${{ inputs.registry }}/forsakringskassan/${{ steps.pkg.outputs.name }}"
          GIT_COMMIT=$(git rev-parse HEAD)
          BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          NEXT_VERSION="${{ steps.version.outputs.nextVersion }}"
          if [ "${{ inputs.release }}" = "true" ]; then
            docker build \
              --build-arg NEXT_VERSION=$NEXT_VERSION \
              --build-arg GIT_COMMIT=$GIT_COMMIT \
              --build-arg IMAGE_NAME=$IMAGE_BASE \
              --build-arg BUILD_DATE="$BUILD_DATE" \
              --label "org.opencontainers.image.source=https://github.com/Forsakringskassan/repository" \
              --label "org.opencontainers.image.description=NPM application: ${{ steps.pkg.outputs.name }}" \
              --label "org.opencontainers.image.licenses=MIT" \
              -t "$IMAGE_BASE:latest" \
              -t "$IMAGE_BASE:$NEXT_VERSION" \
              docker
          fi
          docker build \
            --build-arg NEXT_VERSION=snapshot \
            --build-arg GIT_COMMIT=$GIT_COMMIT \
            --build-arg IMAGE_NAME=$IMAGE_BASE:snapshot \
            --build-arg BUILD_DATE="$BUILD_DATE" \
            --label "org.opencontainers.image.source=https://github.com/Forsakringskassan/repository" \
            --label "org.opencontainers.image.description=NPM application: ${{ steps.pkg.outputs.name }}" \
            --label "org.opencontainers.image.licenses=MIT" \
            -t "$IMAGE_BASE:snapshot" \
            docker
          echo "IMAGE_BASE=$IMAGE_BASE" >> $GITHUB_ENV

      - name: Log in to registry
        run: echo "${{ secrets.PACKAGES_RW_TOKEN }}" | docker login ${{ inputs.registry }} -u ${{ secrets.PACKAGES_RW_ACTOR }} --password-stdin

      - name: Push Docker image(s)
        run: |
          if [ "${{ inputs.release }}" = "true" ]; then
            docker push "$IMAGE_BASE:latest"
            docker push "$IMAGE_BASE:${{ steps.version.outputs.nextVersion }}"
          fi
          docker push "$IMAGE_BASE:snapshot"
        env:
          GH_TOKEN: ${{ secrets.PACKAGES_RW_TOKEN }}

      - name: Push git tag for version
        if: ${{ inputs.release }}
        env:
          GIT_AUTHOR_NAME: github-actions
          GIT_AUTHOR_EMAIL: github-actions@github.com
          GIT_COMMITTER_NAME: github-actions
          GIT_COMMITTER_EMAIL: github-actions@github.com
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ steps.version.outputs.nextVersion }}"
          git tag -a "v$VERSION" -m "Release v$VERSION"
          git push origin "v$VERSION"
